<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mini Geometry Dash</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #111; overflow: hidden; }
    #gameContainer {
      position: relative;
      width: 800px;
      height: 400px;
      margin: 0 auto;
    }
    canvas {
      background: #222 url('https://images.unsplash.com/photo-1503264116251-35a269479413?auto=format&fit=crop&w=800&q=80') no-repeat center center;
      background-size: cover;
      display: block;
    }
    #restartBtn {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      padding: 10px 20px;
      background: #0f0;
      border: none;
      border-radius: 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="game" width="800" height="400"></canvas>
    <button id="restartBtn">Restart</button>
  </div>
  <audio id="bgm" src="https://cdn.pixabay.com/audio/2022/10/03/audio_4b93a3b1a6.mp3" autoplay loop></audio>
  <audio id="jumpSound" src="https://cdn.pixabay.com/audio/2021/08/04/audio_1bfa3eb2c2.mp3"></audio>
  <audio id="hitSound" src="https://cdn.pixabay.com/audio/2022/03/01/audio_2b442727f3.mp3"></audio>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const restartBtn = document.getElementById('restartBtn');
    const jumpSound = document.getElementById('jumpSound');
    const hitSound = document.getElementById('hitSound');

    let angle = 0;

    const player = {
      x: 100,
      y: 300,
      width: 30,
      height: 30,
      dy: 0,
      gravity: 0.8,
      jumpPower: -12,
      doubleJumpPower: -10,
      bouncePower: -16,
      superBouncePower: -20,
      jumpsLeft: 2,
      color: '#0f0',
      jumping: false
    };

    let obstacles = [];
    let platforms = [];
    let bluePads = [];
    let redPads = [];
    let spikeObstacles = [];

    let gameOver = false;
    let speed = 6;
    let score = 0;

    function createObstacle() {
      const height = 40 + Math.random() * 40;
      const isSpike = Math.random() < 0.5;
      if (isSpike) {
        spikeObstacles.push({
          x: canvas.width,
          y: canvas.height - 40,
          width: 20,
          height: 40,
          color: '#ff0',
          type: 'spike'
        });
      } else {
        obstacles.push({
          x: canvas.width,
          y: canvas.height - height,
          width: 20,
          height,
          color: '#f00'
        });
      }
    }

    function createPlatform() {
      const width = 100;
      const height = 30;
      const y = 250 + Math.random() * 100;
      platforms.push({
        x: canvas.width,
        y,
        width,
        height,
        color: '#888'
      });
    }

    function createBluePad() {
      const width = 60;
      const height = 10;
      const y = 280 + Math.random() * 80;
      bluePads.push({
        x: canvas.width,
        y,
        width,
        height,
        color: '#00f'
      });
    }

    function createRedPad() {
      const width = 60;
      const height = 10;
      const y = 280 + Math.random() * 80;
      redPads.push({
        x: canvas.width,
        y,
        width,
        height,
        color: '#f00'
      });
    }

    function drawRect(obj) {
      ctx.fillStyle = obj.color;
      ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
    }

    function drawPlayer() {
      ctx.save();
      ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
      if (player.jumping) {
        angle += 0.3;
        ctx.rotate(angle);
      } else {
        angle = 0;
      }
      ctx.fillStyle = player.jumping ? '#ff0' : player.color;
      ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
      ctx.restore();
    }

    function drawObstacles() { obstacles.forEach(drawRect); }
    function drawPlatforms() { platforms.forEach(drawRect); }
    function drawBluePads() { bluePads.forEach(drawRect); }
    function drawRedPads() { redPads.forEach(drawRect); }
    function drawSpikes() { spikeObstacles.forEach(drawRect); }

    function drawScore() {
      ctx.fillStyle = '#fff';
      ctx.font = '20px Arial';
      ctx.fillText(`Score: ${score}`, 10, 30);
    }

    function checkCollision(rect1, rect2) {
      return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
      );
    }

    function update() {
      if (gameOver) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let prevY = player.y;
      player.dy += player.gravity;
      player.y += player.dy;

      player.jumping = player.dy < 0;

      let onGround = false;

      if (player.y + player.height >= canvas.height) {
        player.y = canvas.height - player.height;
        player.dy = 0;
        onGround = true;
      }

      for (let plat of platforms) {
        plat.x -= speed;
        if (
          prevY + player.height <= plat.y &&
          player.y + player.height >= plat.y &&
          player.x + player.width > plat.x &&
          player.x < plat.x + plat.width &&
          player.dy >= 0
        ) {
          player.y = plat.y - player.height;
          player.dy = 0;
          onGround = true;
        } else if (checkCollision(player, plat)) {
          gameOver = true;
          restartBtn.style.display = 'block';
          hitSound.play();
        }
      }

      for (let pad of bluePads) {
        pad.x -= speed;
        if (
          prevY + player.height <= pad.y &&
          player.y + player.height >= pad.y &&
          player.x + player.width > pad.x &&
          player.x < pad.x + pad.width &&
          player.dy >= 0
        ) {
          player.y = pad.y - player.height;
          player.dy = player.bouncePower;
          onGround = false;
        }
      }

      for (let pad of redPads) {
        pad.x -= speed;
        if (
          prevY + player.height <= pad.y &&
          player.y + player.height >= pad.y &&
          player.x + player.width > pad.x &&
          player.x < pad.x + pad.width &&
          player.dy >= 0
        ) {
          player.y = pad.y - player.height;
          player.dy = player.superBouncePower;
          onGround = false;
        }
      }

      if (onGround) player.jumpsLeft = 2;

      for (let obs of obstacles.concat(spikeObstacles)) {
        obs.x -= speed;
        if (checkCollision(player, obs)) {
          gameOver = true;
          restartBtn.style.display = 'block';
          hitSound.play();
        }
      }

      [obstacles, platforms, bluePads, redPads, spikeObstacles].forEach(arr => {
        while (arr.length > 0 && arr[0] && arr[0].x + arr[0].width < 0) {
          arr.shift();
          score++;
          if (score % 5 === 0) speed += 0.5;
        }
      });

      drawPlayer();
      drawObstacles();
      drawSpikes();
      drawPlatforms();
      drawBluePads();
      drawRedPads();
      drawScore();
    }

    function jump() {
      if (player.jumpsLeft > 0) {
        player.dy = player.jumpsLeft === 2 ? player.jumpPower : player.doubleJumpPower;
        player.jumpsLeft--;
        jumpSound.play();
      }
    }

    function resetGame() {
      player.y = 300;
      player.dy = 0;
      player.jumpsLeft = 2;
      obstacles = [];
      platforms = [];
      bluePads = [];
      redPads = [];
      spikeObstacles = [];
      score = 0;
      speed = 6;
      gameOver = false;
      restartBtn.style.display = 'none';
    }

    restartBtn.addEventListener('click', () => {
      resetGame();
    });

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') jump();
    });

    canvas.addEventListener('click', jump);
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      jump();
    });

    setInterval(() => {
      if (!gameOver) {
        createObstacle();
        if (Math.random() < 0.5) createPlatform();
        if (Math.random() < 0.3) createBluePad();
        if (Math.random() < 0.2) createRedPad();
      }
    }, 2000);

    function gameLoop() {
      update();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
